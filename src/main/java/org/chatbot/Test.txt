
package com.manideepr.chat;

import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.project.DumbService;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.*;
import com.intellij.psi.util.PsiTreeUtil;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.function.Predicate;

/** Builds a compact, budgeted context block for .java files using PSI. */
final class JavaContextExtractor {
  private JavaContextExtractor() {}

  static String buildJavaContext(Project project, VirtualFile vf, int byteBudget) {
    if (DumbService.isDumb(project)) {
      // Indexing: fall back to raw truncation
      return fenced("java", rawTruncate(vf, byteBudget));
    }
    return ReadAction.compute(() -> {
      PsiFile psiFile = PsiManager.getInstance(project).findFile(vf);
      if (!(psiFile instanceof PsiJavaFile javaFile)) {
        return fenced("java", rawTruncate(vf, byteBudget));
      }

      StringBuilder out = new StringBuilder(Math.min(byteBudget, 8192));
      // Header: package + imports
      if (javaFile.getPackageName() != null && !javaFile.getPackageName().isBlank()) {
        out.append("package ").append(javaFile.getPackageName()).append(";\n\n");
      }
      for (PsiImportStatement imp : javaFile.getImportList() != null ? javaFile.getImportList().getImportStatements() : new PsiImportStatement[0]) {
        out.append(imp.getText()).append("\n");
      }
      if (out.length() > 0) out.append("\n");

      // Choose top-level type
      PsiClass[] classes = javaFile.getClasses();
      if (classes.length == 0) {
        return fenced("java", headTail(rawText(vf), byteBudget));
      }
      PsiClass top = classes[0];

      // Class signature
      out.append(signature(top)).append(" {\n");

      // Collect members
      List<PsiMember> members = new ArrayList<>();
      Collections.addAll(members, top.getFields());
      Collections.addAll(members, top.getMethods());
      Collections.addAll(members, top.getInnerClasses());

      // Prioritize relevant methods (names contain common verbs or caret method)
      Set<PsiMethod> preferred = new LinkedHashSet<>();
      Editor ed = FileEditorManager.getInstance(project).getSelectedTextEditor();
      PsiMethod caretMethod = ed != null ? PsiTreeUtil.getParentOfType(javaFile.findElementAt(ed.getCaretModel().getOffset()), PsiMethod.class) : null;
      if (caretMethod != null) preferred.add(caretMethod);

      Predicate<String> isHot = n -> {
        String s = n.toLowerCase(Locale.ROOT);
        return s.contains("init") || s.contains("start") || s.contains("render") || s.contains("build")
            || s.contains("handle") || s.contains("process") || s.contains("service") || s.contains("run")
            || s.contains("execute") || s.contains("update");
      };
      for (PsiMethod m : top.getMethods()) if (isHot.test(m.getName())) preferred.add(m);

      // Budgeted write helper
      BudgetWriter bw = new BudgetWriter(out, byteBudget);

      // 1) Always write field & method signatures (cheap)
      for (PsiField f : top.getFields()) {
        if (!bw.writeLine("  " + signature(f) + ";\n")) return fenced("java", bw.finishWithBrace());
      }
      for (PsiMethod m : top.getMethods()) {
        if (!bw.writeLine("  " + signature(m) + " { /* … */ }\n")) return fenced("java", bw.finishWithBrace());
      }

      // 2) Write bodies for preferred methods first
      for (PsiMethod m : preferred) {
        String body = bodyText(m);
        if (body != null && !body.isBlank()) {
          if (!bw.write("  " + signature(m) + " {\n" + indent(body, 4) + "\n  }\n")) {
            return fenced("java", bw.finishWithBrace());
          }
        }
      }

      // 3) Fill remaining budget with other method bodies (short ones first)
      List<PsiMethod> others = new ArrayList<>(Arrays.asList(top.getMethods()));
      others.removeAll(preferred);
      others.sort(Comparator.comparingInt(m -> (bodyText(m) == null ? Integer.MAX_VALUE : bodyText(m).length())));
      for (PsiMethod m : others) {
        String body = bodyText(m);
        if (body == null || body.isBlank()) continue;
        if (!bw.write("  " + signature(m) + " {\n" + indent(body, 4) + "\n  }\n")) break;
      }

      // Close class
      bw.write("}\n");
      return fenced("java", bw.toString());
    });
  }

  // ---------- helpers ----------

  private static String signature(PsiClass c) {
    StringBuilder s = new StringBuilder();
    s.append(Objects.toString(c.getModifierList() != null ? c.getModifierList().getText() : "", "").trim());
    if (s.length() > 0) s.append(" ");
    s.append(c.isInterface() ? "interface " : c.isEnum() ? "enum " : "class ").append(c.getName());
    PsiReferenceList ext = c.getExtendsList();
    PsiReferenceList impl = c.getImplementsList();
    if (ext != null && ext.getReferenceElements().length > 0) {
      s.append(" extends ").append(ext.getText().replace("extends", "").trim());
    }
    if (impl != null && impl.getReferenceElements().length > 0) {
      s.append(" implements ").append(impl.getText().replace("implements", "").trim());
    }
    return s.toString().replaceAll("\\s+", " ").trim();
  }

  private static String signature(PsiMethod m) {
    String mods = Objects.toString(m.getModifierList().getText(), "").trim();
    String ret = Objects.toString(m.getReturnType() != null ? m.getReturnType().getPresentableText() : "void", "void");
    StringBuilder ps = new StringBuilder();
    ps.append("(");
    PsiParameter[] params = m.getParameterList().getParameters();
    for (int i = 0; i < params.length; i++) {
      if (i > 0) ps.append(", ");
      ps.append(params[i].getType().getPresentableText()).append(" ").append(params[i].getName());
    }
    ps.append(")");
    String name = m.getName();
    String head = ((mods.isEmpty() ? "" : mods + " ") + ret + " " + name + ps).replaceAll("\\s+", " ").trim();
    return head;
  }

  private static String signature(PsiField f) {
    String mods = Objects.toString(f.getModifierList() != null ? f.getModifierList().getText() : "", "").trim();
    String type = Objects.toString(f.getType() != null ? f.getType().getPresentableText() : "var", "var");
    String head = ((mods.isEmpty() ? "" : mods + " ") + type + " " + f.getName()).replaceAll("\\s+", " ").trim();
    return head;
  }

  private static String bodyText(PsiMethod m) {
    PsiCodeBlock b = m.getBody();
    return b == null ? null : b.getText().replaceAll("^\\{\\s*|\\s*}$", "");
  }

  private static String indent(String s, int n) {
    String pad = " ".repeat(n);
    return s.replaceAll("(?m)^", pad);
  }

  private static String rawText(VirtualFile vf) {
    try {
      byte[] bytes = vf.contentsToByteArray();
      return new String(bytes, StandardCharsets.UTF_8);
    } catch (Exception e) {
      return "";
    }
  }

  private static String headTail(String s, int budget) {
    if (s == null) return "";
    byte[] bytes = s.getBytes(StandardCharsets.UTF_8);
    if (bytes.length <= budget) return s;
    int half = Math.max(0, (budget - 64) / 2); // leave for marker & fences
    String head = new String(bytes, 0, Math.min(bytes.length, half), StandardCharsets.UTF_8);
    String tail = new String(bytes, Math.max(0, bytes.length - half), Math.min(half, bytes.length), StandardCharsets.UTF_8);
    return head + "\n/* …omitted… */\n" + tail;
  }

  private static String rawTruncate(VirtualFile vf, int budget) {
    return headTail(rawText(vf), budget);
  }

  private static String fenced(String lang, String body) {
    return "```" + lang + "\n" + (body == null ? "" : body) + "\n```\n";
  }

  /** Writes only while total UTF-8 bytes <= budget. */
  private static final class BudgetWriter {
    private final StringBuilder sb;
    private final int budget;
    BudgetWriter(StringBuilder sb, int budget) { this.sb = sb; this.budget = budget; }
    boolean write(String s) {
      byte[] add = s.getBytes(StandardCharsets.UTF_8);
      if (sb.toString().getBytes(StandardCharsets.UTF_8).length + add.length > budget) return false;
      sb.append(s); return true;
    }
    boolean writeLine(String s) { return write(s); }
    String finishWithBrace() {
      if (!sb.toString().endsWith("}\n")) sb.append("}\n");
      return sb.toString();
    }
    @Override public String toString() { return sb.toString(); }
  }
}









===================


package com.manideepr.chat;

import com.intellij.openapi.project.Project;
import com.intellij.openapi.wm.ToolWindow;
import com.intellij.openapi.wm.ToolWindowFactory;
import com.intellij.ui.SimpleToolWindowPanel;
import com.intellij.ui.content.Content;
import com.intellij.ui.content.ContentFactory;
import com.intellij.util.Disposer;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import java.awt.*;
import java.util.UUID;

public class ChatToolWindowFactory implements ToolWindowFactory {

  private static final int LARGE_THRESHOLD = 8_000;

  @Override
  public void createToolWindowContent(@NotNull Project project, @NotNull ToolWindow toolWindow) {
    SimpleToolWindowPanel root = new SimpleToolWindowPanel(true, true);

    // Center: JCEF markdown view
    JcefMarkdownChatView view = new JcefMarkdownChatView();

    // Context store (selected files)
    ChatContextStore ctx = ChatContextStore.getInstance(project);

    // ---- Bottom input row ----
    // Handler passed to constructor: ONLY mutates the store. No references to `input` here.
    ChatInputPanel input = new ChatInputPanel(
        project,
        text -> { if (!text.isBlank()) ChatService.getInstance(project).ask(null, text); },
        new ChatInputPanel.AddContextHandler() {
          @Override public void addFiles(java.util.List<com.intellij.openapi.vfs.VirtualFile> files) {
            ctx.addFiles(files); // chips will refresh via ctx.onChange
          }
          @Override public void removeFile(com.intellij.openapi.vfs.VirtualFile vf) {
            ctx.removeFile(vf);  // chips will refresh via ctx.onChange
          }
        }
    );

    // Refresh runnable that *can* safely reference `input` (after it's constructed)
    Runnable refreshChips = () ->
        input.setAttachedFiles(
            ctx.getFiles(),
            new ChatInputPanel.AddContextHandler() {
              @Override public void addFiles(java.util.List<com.intellij.openapi.vfs.VirtualFile> files) { ctx.addFiles(files); }
              @Override public void removeFile(com.intellij.openapi.vfs.VirtualFile vf) { ctx.removeFile(vf); }
            }
        );

    // Initial chips + subscribe to context changes
    refreshChips.run();
    ctx.onChange(() -> SwingUtilities.invokeLater(refreshChips));

    // Layout
    JPanel content = new JPanel(new BorderLayout());
    content.add(view.getComponent(), BorderLayout.CENTER);
    content.add(input, BorderLayout.SOUTH);
    root.setContent(content);

    // ---- Hook ChatService -> JCEF view ----
    ChatService chat = ChatService.getInstance(project);
    final String[] pendingIdRef = new String[1];

    chat.setSink(new ChatService.Sink() {
      @Override public void onReset() {
        pendingIdRef[0] = null;
        view.clear();
      }
      @Override public void onUser(String text) {
        view.addUser(text);
        String id = UUID.randomUUID().toString().replace("-", "");
        pendingIdRef[0] = id;
        view.addPendingAssistant(id);
      }
      @Override public void onAssistant(String text) {
        String id = pendingIdRef[0]; pendingIdRef[0] = null;
        if (id != null) {
          if (text != null && text.length() > LARGE_THRESHOLD) {
            view.resolvePendingLarge(id, text);
          } else {
            view.resolvePending(id, text == null ? "" : text);
          }
        } else {
          if (text != null && text.length() > LARGE_THRESHOLD) {
            String tmp = UUID.randomUUID().toString().replace("-", "");
            view.addPendingAssistant(tmp);
            view.resolvePendingLarge(tmp, text);
          } else {
            view.addAssistant(text == null ? "" : text);
          }
        }
      }
      @Override public void onError(String message) {
        String id = pendingIdRef[0]; pendingIdRef[0] = null;
        String md = "```text\n" + (message == null ? "" : message) + "\n```";
        if (id != null) view.resolvePending(id, md); else view.addAssistant(md);
      }
    });

    Content tab = ContentFactory.getInstance().createContent(root, "Chat", false);
    Disposer.register(tab, () -> {
      ChatService.getInstance(project).setSink(null);
      ctx.clear();
    });
    toolWindow.getContentManager().addContent(tab);
  }
}



======

package com.manideepr.chat;

import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.components.Service;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vfs.VfsUtilCore;
import com.intellij.openapi.vfs.VirtualFile;
import org.jetbrains.annotations.NotNull;

import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

@Service(Service.Level.PROJECT)
public final class ChatContextStore {
  public static final int MAX_BYTES_PER_FILE = 80_000;   // ~80 KB/file
  public static final int MAX_FILES = 8;                 // cap number of files

  private final Project project;
  private final List<VirtualFile> files = new CopyOnWriteArrayList<>();
  private final List<Runnable> listeners = new CopyOnWriteArrayList<>();

  public ChatContextStore(Project project) { this.project = project; }

  public static ChatContextStore getInstance(Project p) { return p.getService(ChatContextStore.class); }

  public List<VirtualFile> getFiles() { return Collections.unmodifiableList(files); }

  public void addFiles(Collection<VirtualFile> toAdd) {
    boolean changed = false;
    for (VirtualFile vf : toAdd) {
      if (vf == null) continue;
      if (files.size() >= MAX_FILES) break;
      if (!files.contains(vf) && vf.isValid() && !vf.isDirectory()) {
        files.add(vf);
        changed = true;
      }
    }
    if (changed) notifyListeners();
  }

  public void removeFile(VirtualFile vf) {
    if (files.remove(vf)) notifyListeners();
  }

  public void clear() {
    if (!files.isEmpty()) { files.clear(); notifyListeners(); }
  }

  public void onChange(Runnable r) { listeners.add(r); }
  public void removeListener(Runnable r) { listeners.remove(r); }
  private void notifyListeners() { for (Runnable r : listeners) r.run(); }

  /** Read selected files (truncated) and return a JSON-like section for the prompt. */
  public String buildContextBlock() {
    return ReadAction.compute(() -> {
      StringBuilder sb = new StringBuilder(4096);
      sb.append("## Attached files\n");
      for (VirtualFile vf : files) {
        if (!vf.isValid() || vf.isDirectory()) continue;
        byte[] bytes;
        try {
          bytes = VfsUtilCore.loadBytes(vf);
        } catch (Exception e) {
          continue;
        }
        boolean truncated = bytes.length > MAX_BYTES_PER_FILE;
        int len = Math.min(bytes.length, MAX_BYTES_PER_FILE);
        String text = new String(bytes, 0, len, StandardCharsets.UTF_8);
        sb.append("\n### ").append(vf.getPath()).append("\n");
        sb.append("```").append(extOrText(vf)).append("\n")
          .append(text)
          .append(truncated ? "\n…(truncated)…" : "")
          .append("\n```\n");
      }
      return sb.toString();
    });
  }

  private static String extOrText(@NotNull VirtualFile vf) {
    String ext = vf.getExtension();
    return ext == null || ext.isBlank() ? "text" : ext.toLowerCase(Locale.ROOT);
  }
}

package com.manideepr.chat;

import com.intellij.openapi.fileChooser.FileChooser;
import com.intellij.openapi.fileChooser.FileChooserDescriptor;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.ui.components.JBPanel;
import com.intellij.util.ui.JBUI;

import javax.swing.*;
import java.awt.*;
import java.util.List;
import java.util.function.Consumer;

public class ChatInputPanel extends JBPanel<ChatInputPanel> {
  private final JTextArea area = new JTextArea(3, 20);
  private final JPanel chips = new JPanel(new FlowLayout(FlowLayout.LEFT, 6, 6));

  public interface AddContextHandler { void addFiles(List<VirtualFile> files); void removeFile(VirtualFile vf); }

  public ChatInputPanel(Project project, Consumer<String> onSend, AddContextHandler addCtx) {
    super(new BorderLayout(6, 6));
    setBorder(JBUI.Borders.empty(6, 10));

    // chips row
    chips.setBorder(JBUI.Borders.empty(2, 0));
    chips.setOpaque(false);

    // text area
    area.setLineWrap(true);
    area.setWrapStyleWord(true);
    JScrollPane scroll = new JScrollPane(area);

    // buttons
    JPanel buttons = new JPanel(new FlowLayout(FlowLayout.RIGHT, 6, 6));
    JButton add = new JButton("Add context");
    JButton send = new JButton("Send");

    add.addActionListener(e -> {
      FileChooserDescriptor desc = new FileChooserDescriptor(true, false, false, false, false, true);
      desc.setTitle("Attach files as chat context");
      FileChooser.chooseFiles(desc, project, null, selected -> addCtx.addFiles(selected));
    });

    send.addActionListener(e -> {
      String text = area.getText().trim();
      if (!text.isEmpty()) { onSend.accept(text); area.setText(""); }
    });

    // Enter to send
    area.getInputMap().put(KeyStroke.getKeyStroke("ENTER"), "send");
    area.getActionMap().put("send", new AbstractAction() {
      @Override public void actionPerformed(java.awt.event.ActionEvent e) { send.doClick(); }
    });

    buttons.add(add);
    buttons.add(send);

    add(chips, BorderLayout.NORTH);
    add(scroll, BorderLayout.CENTER);
    add(buttons, BorderLayout.SOUTH);
  }

  /** Re-render the file chips with tiny “x” remove buttons. */
  public void setAttachedFiles(List<VirtualFile> files, AddContextHandler addCtx) {
    chips.removeAll();
    for (VirtualFile vf : files) {
      JPanel pill = new JPanel(new FlowLayout(FlowLayout.CENTER, 4, 0));
      pill.setBorder(JBUI.Borders.compound(
          JBUI.Borders.customLine(JBUI.CurrentTheme.Popup.borderColor(true), 1),
          JBUI.Borders.empty(2, 6)));
      JLabel name = new JLabel(shortPath(vf));
      JButton x = new JButton("×");
      x.setMargin(new Insets(0,4,0,4));
      x.setFocusable(false);
      x.addActionListener(e -> addCtx.removeFile(vf));
      pill.add(name); pill.add(x);
      chips.add(pill);
    }
    chips.revalidate(); chips.repaint();
  }

  private static String shortPath(VirtualFile vf) {
    String p = vf.getPath();
    if (p.length() > 60) return "…" + p.substring(Math.max(0, p.length()-57));
    return p;
  }
}

package com.manideepr.chat;

import com.intellij.openapi.project.Project;
import com.intellij.openapi.wm.ToolWindow;
import com.intellij.openapi.wm.ToolWindowFactory;
import com.intellij.ui.SimpleToolWindowPanel;
import com.intellij.ui.content.Content;
import com.intellij.ui.content.ContentFactory;
import com.intellij.util.Disposer;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import java.awt.*;

public class ChatToolWindowFactory implements ToolWindowFactory {

  @Override
  public void createToolWindowContent(@NotNull Project project, @NotNull ToolWindow toolWindow) {
    SimpleToolWindowPanel root = new SimpleToolWindowPanel(true, true);

    // Center JCEF markdown chat view (your existing one with spinner/large support)
    JcefMarkdownChatView view = new JcefMarkdownChatView();

    ChatContextStore ctx = ChatContextStore.getInstance(project);

    // Bottom input row now gets project + handlers
    ChatInputPanel input = new ChatInputPanel(project, text -> {
      if (!text.isBlank()) {
        ChatService.getInstance(project).ask(null, text);
      }
    }, new ChatInputPanel.AddContextHandler() {
      @Override public void addFiles(java.util.List<com.intellij.openapi.vfs.VirtualFile> files) {
        ctx.addFiles(files);
        input.setAttachedFiles(ctx.getFiles(), this);
      }
      @Override public void removeFile(com.intellij.openapi.vfs.VirtualFile vf) {
        ctx.removeFile(vf);
        input.setAttachedFiles(ctx.getFiles(), this);
      }
    });

    // Initial chip state + react to external changes (e.g., clear)
    input.setAttachedFiles(ctx.getFiles(), new ChatInputPanel.AddContextHandler() {
      @Override public void addFiles(java.util.List<com.intellij.openapi.vfs.VirtualFile> files) { /* not used here */ }
      @Override public void removeFile(com.intellij.openapi.vfs.VirtualFile vf) { /* not used here */ }
    });
    ctx.onChange(() -> SwingUtilities.invokeLater(() ->
        input.setAttachedFiles(ctx.getFiles(), new ChatInputPanel.AddContextHandler() {
          @Override public void addFiles(java.util.List<com.intellij.openapi.vfs.VirtualFile> files) { ctx.addFiles(files); }
          @Override public void removeFile(com.intellij.openapi.vfs.VirtualFile vf) { ctx.removeFile(vf); }
        })));

    JPanel content = new JPanel(new BorderLayout());
    content.add(view.getComponent(), BorderLayout.CENTER);
    content.add(input, BorderLayout.SOUTH);
    root.setContent(content);

    // Hook ChatService -> JCEF view (same as you already have)
    ChatService chat = ChatService.getInstance(project);
    final String[] pendingIdRef = new String[1];
    chat.setSink(new ChatService.Sink() {
      @Override public void onReset() { pendingIdRef[0] = null; view.clear(); }
      @Override public void onUser(String text) {
        view.addUser(text);
        String id = java.util.UUID.randomUUID().toString().replace("-", "");
        pendingIdRef[0] = id;
        view.addPendingAssistant(id);
      }
      @Override public void onAssistant(String text) {
        String id = pendingIdRef[0]; pendingIdRef[0] = null;
        if (id != null) {
          if (text != null && text.length() > 8000) view.resolvePendingLarge(id, text);
          else view.resolvePending(id, text == null ? "" : text);
        } else {
          if (text != null && text.length() > 8000) {
            String tmp = java.util.UUID.randomUUID().toString().replace("-", "");
            view.addPendingAssistant(tmp); view.resolvePendingLarge(tmp, text);
          } else view.addAssistant(text == null ? "" : text);
        }
      }
      @Override public void onError(String message) {
        String id = pendingIdRef[0]; pendingIdRef[0] = null;
        String md = "```text\n" + (message == null ? "" : message) + "\n```";
        if (id != null) view.resolvePending(id, md); else view.addAssistant(md);
      }
    });

    Content tab = ContentFactory.getInstance().createContent(root, "Chat", false);
    Disposer.register(tab, () -> {
      ChatService.getInstance(project).setSink(null);
      ctx.clear();
    });
    toolWindow.getContentManager().addContent(tab);
  }
}


package com.manideepr.chat;

import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.components.Service;
import com.intellij.openapi.project.Project;
import org.chatbot.ChatBotAPI;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@Service(Service.Level.PROJECT)
public final class ChatService {
  private final Project project;
  public ChatService(Project project) { this.project = project; }

  public interface Sink {
    void onUser(String text);
    void onAssistant(String text);
    void onError(String message);
    default void onReset() {}
  }

  private enum Role { USER, ASSISTANT, ERROR }
  private static final class Msg {
    final Role role; final String text;
    Msg(Role role, String text) { this.role = role; this.text = text; }
  }

  private final List<Msg> transcript = Collections.synchronizedList(new ArrayList<>());
  private volatile @Nullable Sink sink;

  public static ChatService getInstance(Project project) { return project.getService(ChatService.class); }

  public void setSink(@Nullable Sink sink) {
    this.sink = sink;
    if (sink == null) return;
    sink.onReset();
    List<Msg> snap;
    synchronized (transcript) { snap = new ArrayList<>(transcript); }
    for (Msg m : snap) switch (m.role) {
      case USER -> sink.onUser(m.text);
      case ASSISTANT -> sink.onAssistant(m.text);
      case ERROR -> sink.onError(m.text);
    }
  }

  public void ask(@Nullable String selection, String question) {
    recordAndNotify(Role.USER, question);

    ApplicationManager.getApplication().executeOnPooledThread(() -> {
      try {
        // Build context ONLY from explicitly attached files
        String ctxBlock = ChatContextStore.getInstance(project).buildContextBlock();

        StringBuilder prompt = new StringBuilder(4096);
        prompt.append("You are an IDE assistant. Use the attached files as primary context.\n\n");
        prompt.append("## Question\n").append(question).append("\n\n");
        if (selection != null && !selection.isBlank()) {
          prompt.append("## Editor selection\n").append(selection).append("\n\n");
        }
        if (!ctxBlock.isBlank()) prompt.append(ctxBlock);

        String answer = ChatBotAPI.ask(prompt.toString());

        ApplicationManager.getApplication().invokeLater(() ->
            recordAndNotify(Role.ASSISTANT, answer));
      } catch (Exception ex) {
        ApplicationManager.getApplication().invokeLater(() ->
            recordAndNotify(Role.ERROR, "Request failed: " + ex.getMessage()));
      }
    });
  }

  private void recordAndNotify(Role role, String text) {
    transcript.add(new Msg(role, text));
    Sink s = sink; if (s == null) return;
    switch (role) {
      case USER -> s.onUser(text);
      case ASSISTANT -> s.onAssistant(text);
      case ERROR -> s.onError(text);
    }
  }
}





