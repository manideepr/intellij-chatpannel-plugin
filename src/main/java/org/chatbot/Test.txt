package com.manideepr.chat;

import com.intellij.ui.jcef.JBCefBrowser;
import com.intellij.ui.jcef.JBCefClient;
import com.intellij.ui.jcef.JBCefJSQuery;
import org.cef.browser.CefBrowser;
import org.cef.browser.CefFrame;
import org.cef.handler.CefDisplayHandlerAdapter;
import org.cef.handler.CefLoadHandlerAdapter;

import javax.swing.*;
import java.awt.*;
import java.awt.datatransfer.StringSelection;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;

public final class JcefMarkdownChatView {
  private final JBCefBrowser browser;
  private final JBCefJSQuery copyQuery;

  // Page-load buffering
  private volatile boolean ready = false;
  private final List<String> pendingJs = new ArrayList<>();

  public JcefMarkdownChatView() {
    this.browser = new JBCefBrowser();
    this.copyQuery = JBCefJSQuery.create(browser);

    // JS -> Java Copy bridge
    copyQuery.addHandler(text -> {
      Toolkit.getDefaultToolkit().getSystemClipboard()
          .setContents(new StringSelection(text), null);
      return null;
    });

    // Console logs from JS
    JBCefClient client = browser.getJbCefClient();
    client.addDisplayHandler(new CefDisplayHandlerAdapter() {
      @Override
      public boolean onConsoleMessage(CefBrowser b, int level, String message, String source, int line) {
        System.out.println("[JCEF] " + message + " (" + source + ":" + line + ")");
        return false;
      }
    }, browser.getCefBrowser());

    // Ready flag on load end
    client.addLoadHandler(new CefLoadHandlerAdapter() {
      @Override
      public void onLoadEnd(CefBrowser b, CefFrame frame, int httpStatusCode) {
        if (frame.isMain()) {
          ready = true;
          flushPending();
        }
      }
    }, browser.getCefBrowser());

    String injected = copyQuery.inject("atob(arguments[0])"); // copy bridge expects base64->text
    browser.loadHTML(buildHtml(injected));
  }

  public JComponent getComponent() { return browser.getComponent(); }

  public void clear() { run("clearRoot();"); }

  public void addUser(String markdown) {
    run("appendMarkdown('user', " + toJsString(markdown) + ");");
  }

  public void addAssistant(String markdown) {
    run("appendMarkdown('assistant', " + toJsString(markdown) + ");");
  }

  public void addPendingAssistant(String id) {
    run("addPending('assistant', " + toJsString(id) + ");");
  }

  public void resolvePending(String id, String markdown) {
    run("resolvePending(" + toJsString(id) + ", " + toJsString(markdown) + ");");
  }

  /** Large content path: stream Base64 in chunks to JS. */
  public void resolvePendingLarge(String id, String markdown) {
    String b64 = Base64.getEncoder().encodeToString(markdown.getBytes(StandardCharsets.UTF_8));
    // Use a multiple of 4 to keep chunk boundaries Base64-aligned (defensive, though we rejoin before decode)
    int chunkSize = 8192; // 8k chars, multiple of 4
    run("startBig(" + toJsString(id) + ");");
    for (int i = 0; i < b64.length(); i += chunkSize) {
      String part = b64.substring(i, Math.min(i + chunkSize, b64.length()));
      run("appendBig(" + toJsString(id) + ", '" + part + "');"); // part is pure Base64
    }
    run("finishBig(" + toJsString(id) + ");");
  }

  // ---------- internals ----------

  private void run(String js) {
    if (!ready) {
      synchronized (pendingJs) { pendingJs.add(js); }
      return;
    }
    browser.getCefBrowser().executeJavaScript(js, "about:blank", 0);
  }

  private void flushPending() {
    List<String> snapshot;
    synchronized (pendingJs) {
      snapshot = new ArrayList<>(pendingJs);
      pendingJs.clear();
    }
    for (String js : snapshot) {
      browser.getCefBrowser().executeJavaScript(js, "about:blank", 0);
    }
  }

  private static String toJsString(String s) {
    if (s == null) s = "";
    return "'" + s
        .replace("\\", "\\\\")
        .replace("'", "\\'")
        .replace("\r", "\\r")
        .replace("\n", "\\n")
        .replace("\u2028", "\\u2028")
        .replace("\u2029", "\\u2029")
        .replace("\u0000", "")
        + "'";
  }

  private static String buildHtml(String copyBridgeCall) {
    String html = """
      <!doctype html>
      <html>
      <head>
        <meta charset="utf-8"/>
        <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data:;">
        <style>
          :root {
            --bg:#ffffff; --fg:#1f2328; --muted:#6e7781;
            --bubble-user:#e6f3ff; --bubble-assistant:#f6f8fa;
            --code-bg:#0b1020; --code-fg:#e6edf3; --border:#d0d7de;
          }
          @media (prefers-color-scheme: dark){
            :root { --bg:#0d1117; --fg:#c9d1d9; --muted:#8b949e;
                    --bubble-user:#172b3a; --bubble-assistant:#161b22;
                    --code-bg:#0b1020; --code-fg:#e6edf3; --border:#30363d; }
          }
          html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);
            font:13px/1.5 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif;overflow:hidden;}
          #root{box-sizing:border-box;padding:12px 14px 80px;height:100vh;overflow-y:auto;}
          .msg{max-width:840px;border-radius:12px;padding:10px 12px;margin:8px 0;border:1px solid var(--border);word-wrap:break-word;white-space:pre-wrap;}
          .user{margin-left:auto;background:var(--bubble-user);}
          .assistant{margin-right:auto;background:var(--bubble-assistant);}

          code.inline{background:rgba(110,118,129,.2);padding:1px 4px;border-radius:6px;
            font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;font-size:12px;}

          .codewrap{position:relative;margin:8px 0;border:1px solid var(--border);border-radius:10px;background:var(--code-bg);color:var(--code-fg);}
          .codewrap .toolbar{position:absolute;top:6px;right:8px;display:flex;gap:6px;}
          .codewrap .toolbar button{border:1px solid var(--border);background:rgba(240,240,240,.1);color:var(--fg);
            border-radius:6px;font-size:12px;padding:2px 6px;cursor:pointer;}
          .codewrap pre{margin:0;padding:30px 12px 12px;overflow:auto;}
          .codewrap code{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;font-size:12px;white-space:pre;}
          .lang-badge{position:absolute;left:10px;top:8px;font-size:11px;color:var(--muted);}

          .pending{display:flex;align-items:center;gap:8px;min-height:22px;}
          .spinner{width:16px;height:16px;border-radius:50%;border:2px solid var(--border);border-top-color:transparent;animation:spin .8s linear infinite;}
          @keyframes spin{to{transform:rotate(360deg)}}
          .pending-text{color:var(--muted);font-size:12px;}
          .raw pre{white-space:pre-wrap;}
        </style>
      </head>
      <body>
        <div id="root"></div>

        <script>
          function esc(s){return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');}

          function renderMarkdown(md){
            if(!md) return '';
            const codeBlocks=[];
            md=md.replace(/```([A-Za-z0-9_+.-]*)\\n([\\s\\S]*?)```/g,(_,lang,code)=>{
              const i=codeBlocks.push({lang:(lang||'text'),code})-1; return '@@CODEBLOCK_'+i+'@@';
            });
            md=esc(md)
              .replace(/\\*\\*([^*]+)\\*\\*/g,'<strong>$1</strong>')
              .replace(/\\*([^*]+)\\*/g,'<em>$1</em>')
              .replace(/`([^`]+)`/g,'<code class="inline">$1</code>')
              .replace(/\\[([^\\]]+)\\]\\((https?:\\/\\/[^)]+)\\)/g,'<a href="$2" target="_blank" rel="noreferrer">$1</a>');
            md='<p>'+md.replace(/\\n{2,}/g,'</p><p>').replace(/\\n/g,'<br/>')+'</p>';
            md=md.replace(/@@CODEBLOCK_(\\d+)@@/g,(_,i)=>{
              const blk=codeBlocks[+i]; const lang=(blk.lang||'text').trim();
              const codeEsc=esc(blk.code??''); const encoded=btoa(blk.code??'');
              return '<div class="codewrap"><div class="toolbar"><button onclick="__copy(\\''+encoded+'\\')">Copy</button></div>'
                     + '<span class="lang-badge">'+esc(lang)+'</span>'
                     + '<pre><code data-lang="'+esc(lang)+'">'+codeEsc+'</code></pre></div>';
            });
            return md;
          }

          function addMessage(role, html){
            const el=document.createElement('div'); el.className='msg '+role; el.innerHTML=html;
            document.getElementById('root').appendChild(el);
            requestAnimationFrame(()=>window.scrollToBottom());
          }
          window.scrollToBottom=function(){ const root=document.getElementById('root'); root.scrollTop=root.scrollHeight; };

          // Public API
          window.appendMarkdown=(role,md)=>addMessage(role,renderMarkdown(md));
          window.clearRoot=()=>{ document.getElementById('root').innerHTML=''; };

          // Spinner helpers
          window.addPending=(role,id)=>{
            const el=document.createElement('div'); el.className='msg '+role; el.id='msg-'+id;
            el.innerHTML='<div class="pending"><div class="spinner"></div><div class="pending-text">Thinkingâ€¦</div></div>';
            document.getElementById('root').appendChild(el);
            requestAnimationFrame(()=>window.scrollToBottom());
          };
          window.resolvePending=(id,md)=>{
            const el=document.getElementById('msg-'+id);
            if(!el){ addMessage('assistant',renderMarkdown(md)); return; }
            el.innerHTML=renderMarkdown(md);
            requestAnimationFrame(()=>window.scrollToBottom());
          };

          // ===== Chunked Base64 transport (Java -> JS) =====
          const __bigBuf = {};
          // Decode joined Base64 in safe segments aligned to 4 chars (Base64 quantum).
          function decodeJoinedB64ToBytes(joined) {
            const step = 16384; // chars per slice; multiple of 4; safe size for atob
            const byteChunks = [];
            let i = 0;
            while (i < joined.length) {
              let end = Math.min(i + step, joined.length);
              // align to 4-char boundary unless it's the last slice
              if (end < joined.length) {
                const rem = (end - i) & 3;
                if (rem !== 0) end -= rem;
              }
              const slice = joined.slice(i, end);
              if (slice.length === 0) break;
              const bin = atob(slice);
              const bytes = new Uint8Array(bin.length);
              for (let j=0; j<bin.length; j++) bytes[j] = bin.charCodeAt(j) & 0xff;
              byteChunks.push(bytes);
              i = end;
            }
            // concat
            let total = 0;
            for (const a of byteChunks) total += a.length;
            const all = new Uint8Array(total);
            let off = 0;
            for (const a of byteChunks) { all.set(a, off); off += a.length; }
            return all;
          }

          window.startBig = (id) => { __bigBuf[id] = []; };
          window.appendBig = (id, b64part) => { (__bigBuf[id] ||= []).push(b64part); };
          window.finishBig = (id) => {
            try {
              const parts = __bigBuf[id] || [];
              delete __bigBuf[id];
              const joined = parts.join('');
              // quick raw preview (before heavy markdown)
              const rawHtml = '<div class="raw"><pre>' + esc((()=>{ try { return new TextDecoder("utf-8").decode(decodeJoinedB64ToBytes(joined)); } catch(e){ return "Decode failed: " + String(e); } })()) + '</pre></div>';
              let el = document.getElementById('msg-'+id);
              if (!el) {
                addMessage('assistant', rawHtml);
                // no el to upgrade; we already appended raw
                return;
              }
              el.innerHTML = rawHtml;
              requestAnimationFrame(() => {
                try {
                  const md = new TextDecoder('utf-8').decode(decodeJoinedB64ToBytes(joined));
                  el.innerHTML = renderMarkdown(md);
                } catch (e) {
                  console.error('finishBig markdown render error', e);
                  el.innerHTML = renderMarkdown('```text\\nRender failed: ' + String(e && e.message || e) + '\\n```');
                }
                requestAnimationFrame(()=>window.scrollToBottom());
              });
            } catch (e) {
              console.error('finishBig error', e);
              const el = document.getElementById('msg-'+id);
              const msg = '```text\\nRender failed: ' + String(e && e.message || e) + '\\n```';
              if (!el) addMessage('assistant', renderMarkdown(msg));
              else { el.innerHTML = renderMarkdown(msg); }
            }
          };

          // Copy bridge (replaced safely from Java)
          const __copyBridge = __COPY_BRIDGE__;
          window.__copy = (encoded) => { __copyBridge(encoded); };
        </script>
      </body>
      </html>
      """;
    return html.replace("__COPY_BRIDGE__", copyBridgeCall);
  }
}
